<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="Generator" content="EditPlus®">
		<meta name="Author" content="">
		<meta name="Keywords" content="">
		<meta name="Description" content="">
		<title>任务八：基础JavaScript练习（二）</title>
		<!--
			任务目的:熟练JavaScript&学习树这种数据结构的基本知识
			
			任务描述:基于任务七,将二叉树变成多叉树,并且每一个节点都带有内容.
				1.提供一个按钮,显示开始遍历,点击后,以动画的形式呈现遍历的过程
				2.增加一个输入框及一个查询按钮,点击按钮时,开始在树中以动画形式查找节点内容和输入框中内容一致的节点,以特殊样式显示
					若找不到则给出提示
		-->
		<style>
			*{
				padding:0;
				margin:0;
			}
			.BST{
				width:1200px;
				height:400px;
				margin:20px auto;
				border:2px solid #3366ff;
				background:#fff;
				color:#000;
				display:flex;
				justify-content:space-around;/*主轴:伸缩项目会平均地分布在行里,两端保留一半的空间*/
				align-items:center;/*侧轴:伸缩项目的外边距盒在该行的侧轴上居中放置*/
			}
			.second{
				width:55%;/*宽度设置过小内容会溢出*/
				height:300px;
				border:1px solid #3366ff;
				color:#000;
				margin:0 10px;/*盒子之间保持一定的距离*/
				background:#fff;
				display:flex;
				justify-content:space-around;/*主轴:伸缩项目会平均地分布在行里,两端保留一半的空间*/
				align-items:center;/*侧轴:伸缩项目的外边距盒在该行的侧轴上居中放置*/
			}
			.third{
				width:75%;/*宽度设置过小内容会溢出*/
				height:100px;
				border:1px solid #3366ff;
				margin:0 10px;/*盒子之间保持一定的距离*/
				background:#fff;
				color:#000;
				display:flex;
				justify-content:space-around;/*主轴:伸缩项目会平均地分布在行里,两端保留一半的空间*/
				align-items:center;/*侧轴:伸缩项目的外边距盒在该行的侧轴上居中放置*/
			}
			.forth{
				width:55%;/*宽度设置过小内容会溢出*/
				height:50px;
				border:1px solid #3366ff;
				color:#000;
				margin:0 10px;/*盒子之间保持一定的距离*/
				background:#fff;
			}
			.control{
				text-align:center;
				color:#000;
			}
		</style>
	</head>
	<body>
		<div class="container"><!--大盒子包裹多叉树,不然广度搜索root.nextElementSibling会把按钮部分的div算进去-->
			<div class="BST" id="root">Apple<!--文本要放在最前面,否则,若文本放在div最后,使用firstChild.nodeValue有可能只获取到空格-->
				<div class="second">Div
					<div class="third">Link
						<div class="forth">Head</div>
						<div class="forth">Div</div>
						<div class="forth">Class</div>
					</div>
					<div class="third">Ball
						<div class="forth">Word</div>
						<div class="forth">Real</div>
					</div>
					<div class="third">Hen
						<div class="forth">Football</div>
					</div>
				</div>
				<div class="second">Title
					<div class="third">Cat
						<div class="forth">Banana</div>
						<div class="forth">Orange</div>
					</div>
				</div>
			</div>
		</div>
		<div class="control">
			<input type="button" value="前序(深度优先)遍历" id="preOrder"/>
			<input type="button" value="后序遍历" id="postOrder"/>
			<input type="button" value="广度优先遍历" id="traverseBf"/>
			<br/>
			<input type="text" placeholder="请输入要搜索的文本" id="inputBox">
			<br/>
			<input type="button" value="前序(深度优先)查询" id="preOrderSearch"/>
			<input type="button" value="后序查询" id="postOrderSearch"/>
			<input type="button" value="广度优先查询" id="traverseBfSearch"/>
		</div>
		<script>
			var timer=null;//声明计时器
			var root=document.getElementById("root");
			var oPreOrder=document.getElementById("preOrder");//深度优先遍历
			var oPostOrder=document.getElementById("postOrder");//后序遍历
			var oTraverseBf=document.getElementById("traverseBf");//广度优先遍历
			var oPreOrderSearch=document.getElementById("preOrderSearch");//深度优先查询
			var oPostOrderSearch=document.getElementById("postOrderSearch");//后序查询
			var oTraverseBfSearch=document.getElementById("traverseBfSearch");//广度优先查询
			var arr=[];
			var index=0;//树的深度
			var flag=false;//判断是否找到
			//前序遍历(深度优先遍历)
			//只需要一个栈空间来压栈。因为深度优先遍历，遍历了根节点后，就开始遍历左子树，所以右子树肯定最后遍历。
			function preOrder(root){
				if(root){
					arr.push(root);//先添加根节点
					//通过children获取所有的子节点,依次将节点添加到数组中
					var childrenNodes=root.children;
					for(var i=0;i<childrenNodes.length;i++){
						preOrder(childrenNodes[i]);
					}
				}
			}
			//后序遍历
			function postOrder(root){
				if(root){
					var childrenNodes=root.children;
					for(var i=0;i<childrenNodes.length;i++){
						postOrder(childrenNodes[i]);
					}
					arr.push(root);//最后添加根节点
				}
			}
			//广度优先遍历
			//广度优先遍历是从二叉树的第一层（根结点）开始，自上至下逐层遍历；在同一层中，按照从左到右的顺序对结点逐一访问。
			function traverseBf(root){
				if(root){
					arr.push(root);
					traverseBf(root.nextElementSibling);//返回元素节点之后的兄弟元素节点
					root=arr[index++];
					traverseBf(root.firstElementChild);//返回子元素的element节点 
				}
			}
			//边框变化动画
			function start(){
				var inputValue=document.getElementById("inputBox").value;
				var key=[];//存储匹配文本的div的索引值
				var i=0;
				//第一个元素的边框线设置为红色
				arr[i].style.border="1px solid #FF7F7F";
				arr[i].style.color="#FF7F7F";
				if(inputValue!=="" && arr[i].firstChild.nodeValue.indexOf(inputValue)!=-1){
					//clearInterval(timer);
					//alert("找到了!");
					arr[i].style.background="#FF7F7F";
					arr[i].style.color="#fff";
					flag=true;
					key.push(i);
				}
				timer=setInterval(function(){
					//当i=0时,i++之后为1;
					i++;
					//后一个边框变色之后,前一个边框颜色重置为初始颜色
					if(i<arr.length){
						arr[i].style.border="1px solid #FF7F7F";
						arr[i].style.color="#FF7F7F";
						arr[i-1].style.border="1px solid #3366ff";
						arr[i-1].style.background="#fff";
						arr[i-1].style.color="#000";
						//使用firstChild.nodeValue来只获取自身内容,而不获取子元素的内容.通过indexOf判断输入的值是否与节点的文本匹配
						//console.log(arr[i].firstChild.nodeValue)
						if(inputValue!=="" && arr[i].firstChild.nodeValue.indexOf(inputValue)!=-1){
							//clearInterval(timer);
							//alert("找到了!");
							arr[i].style.background="#FF7F7F";
							arr[i].style.color="#fff";
							flag=true;
							key.push(i);
						}
					}else{
						//遍历完成后,清除定时器,重置最后一个边框颜色
						clearInterval(timer);
						arr[i-1].style.border="1px solid #3366ff";
						arr[i-1].style.color="#000";
						if(flag==true){
							//clearInterval(timer);
							alert("找到了!");
							console.log(key)
							for(var j=0;j<key.length;j++){
								arr[key[j]].style.background="#FF7F7F";
								arr[key[j]].style.color="#fff";
							}
						}
					}
				},500);
			}
			//重置边框颜色和数组
			function reset(){
				arr=[];
				index=0;//树的深度
				clearInterval(timer);
				flag=false;//默认没找到文本
				var divs=document.getElementsByTagName("div");
				for(var i=1;i<divs.length-1;i++){//大盒子div和按钮div排除
					divs[i].style.border="1px solid #3366ff";
					divs[i].style.background="#fff";
					divs[i].style.color="#000";
				}
			}
			//使用事件委托来提高性能
			//当按钮按下的时候,重置边框颜色,运行遍历,开始动画
			oPreOrder.addEventListener("click",function(){
				reset();
				document.getElementById("inputBox").value="";//文本框清空,否则会误认为是搜索
				preOrder(root);
				start();
			});
			oPostOrder.addEventListener("click",function(){
				reset();
				document.getElementById("inputBox").value="";//文本框清空,否则会误认为是搜索
				postOrder(root);
				start();
			});
			oTraverseBf.addEventListener("click",function(){
				reset();
				document.getElementById("inputBox").value="";//文本框清空,否则会误认为是搜索
				traverseBf(root);
				start();
			});
			oPreOrderSearch.addEventListener("click",function(){
				var inputValue=document.getElementById("inputBox").value;
				reset();
				preOrder(root);
				if(inputValue!==""){
					start();
				}else{
					alert("请输入字符");
				}
			});
			oPostOrderSearch.addEventListener("click",function(){
				var inputValue=document.getElementById("inputBox").value;
				reset();
				postOrder(root);
				if(inputValue!==""){
					
					start();
				}else{
					alert("请输入字符");
				}
			});
			oTraverseBfSearch.addEventListener("click",function(){
				var inputValue=document.getElementById("inputBox").value;
				reset();
				traverseBf(root);
				if(inputValue!==""){
					start();
				}else{
					alert("请输入字符");
				}
			});
		</script>
	</body>
</html>
		<!--
			树可谓是web开发者最常碰到的数据结构之一了. 整张网页就是一棵DOM树(Document Object Model).
			多叉树主要有两种遍历方法:Depth-First Search( DFS, 深度优先遍历 ),和 Breadth-First Search( BFS, 宽度/广度优先遍历 ). 
				DFS方法使用借助栈( stack ) 这一数据结构来访问树的每个节点
				BFS则借助了队列( queue ).


			使用nextSibling属性返回指定节点之后的下一个兄弟节点，（即：相同节点树层中的下一个节点）。
				nextSibling属性与nextElementSibling属性的差别： 
				nextSibling属性返回元素节点之后的兄弟节点（包括文本节点、注释节点即回车、换行、空格、文本等等）； 
				nextElementSibling属性只返回元素节点之后的兄弟元素节点（不包括文本节点、注释节点）；


			以后写js的时候，如果想获取到子元素的element节点，最好使用children方法(在所有主流浏览器中都兼容，包括ie678，并且它也能实现firstElementChild的功能)
				(1)firstElementChild这个方法在现代浏览器中兼容，但是在ie678中却没有这个方法，一旦在ie678中使用这个方法就会出错。
				(2)childNodes方法以及firstChild方法在现代浏览器中使用，都会把元素标签中的空白节点检测出来，一般我们使用这两个方法都是为了获取到元素的元素节点，空白节点会给我们造成很多不必要的bug,
			而children方法则是只检测element元素节点，防范于未然，所以推荐大家以后使用children方法来替代childNodes。
		-->